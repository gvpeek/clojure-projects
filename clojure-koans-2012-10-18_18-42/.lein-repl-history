(= 2 2/1)
(= 2 2.0)
(= 2 2/1 "2")
(= 2 [2])
(= 2 (2))
(= 2 :a=2)
(= 2 2.0)
(type 2.0)
(type 2)
(= 2 2M)
(== 2 2.0))
(== 2 2.0)
(== 2 2.0 2/1)
(= 2 2/1 2N)
(exit)
(= '(1 2 3 4 5) (list 1 2 3 4 5))
(conj (1 2) 3)
(conj '(1 2) 3)
(cons '(1 2) 3)
(cons 3 '(1 2))
(pop (1 2 3))
(pop '(1 2 3))
(1 2 3)
'(1 2 3)
[1 2 3]
(vec nil)
(vector nil)
(= #{} (set nil))
(hash-map)
(count (hash-map))
({:a 1 :b 2} :a)
({:a 1 :b 2} :b)
(:b {:a 1 :b 2})
(get {:a 1} :b)
(5 (fn [n] (* n n)))
([5] (fn [n] (* n n)))
(5 (fn [n] (* n n)))
((5) (fn [n] (* n n)))
('(5) (fn [n] (* n n)))
((+ 5) (fn [n] (* n n)))
(fn [n] (* n n))
((fn [n] (* n n)) 5)
(5 (fn [n] (* n n)))
(fn 5 (fn [n] (* n n)))
(fn [5] (fn [n] (* n n)))
(fn [x] (fn [n] (* n n)))
(fn [x 5] (fn [n] (* n n)))
(fn ['5] (fn [n] (* n n)))
(fn [5] (fn [n] (* n n)))
(map 5 (fn [n] (* n n)))
(map 5 '(fn [n] (* n n)))
(#(5) (fn [n] (* n n)))
(#(+ 5) (fn [n] (* n n)))
(#(+ 5 %) (fn [n] (* n n)))
(map #(+ 5 %) (fn [n] (* n n)))
((+ 2 3) (fn [n] (* n n)))
(fn [] (fn [n] (* n n)))
(fn [5] (fn [n] (* n n)))
(fn x [5] (fn [n] (* n n)))
(fn x [] (fn [n] (* n n)))
(fn x [] 5 (fn [n] (* n n)))
(#(+ 5 %) (fn [n] (* n n)))
(#(5 %) (fn [n] (* n n)))
(#(fn 5 %) (fn [n] (* n n)))
(#(partial 5 %) (fn [n] (* n n)))
((partial 5 %) (fn [n] (* n n)))
((partial 5) (fn [n] (* n n)))
((partial 5 (fn [n] (* n n)))
)
(partial 5 (fn [n] (* n n)))
(comp 5 (fn [n] (* n n)))
(comp #(5) (fn [n] (* n n)))
((fn [f] (+ f 0) (fn [n] (* n n))))
((fn [f] (+ f 0)) (fn [n] (* n n)))
((fn [f] (+ f 0) 5 ) (fn [n] (* n n)))
((fn [f] (+ f 0)) 5 (fn [n] (* n n)))
((fn [f] (f 5)) (fn [n] (* n n)))
(fn [f] (f 'abc))
(fn [f] (f 'abc'))
(fn [f)
(fn [f])
((fn [f]) 5)
((fn [f]) (f) 5)
((fn [f]) (x f) 5)
((fn [f]) (:x f) 5)
(if (> 4 3) 
[])
(if (< 4 3) []) 
(nil? 0)
(defn abcde [x] (case x :a 1 :b 2))
(abcde :a)
(abcde :c)
(defn abcde [x] (case x :a 1 :b 2 :c))
(abcde :c)
(abcde :d)
(map nil? [1])
(map nil? [1 2])
(map nil? [1 2 nil])
(filter (fn [x] false) :a)
(filter (fn [x] false) :a))
(filter (fn [x] false))
(filter (fn [x] false) [1])
(filter (fn [x] false) [true])
(filter (fn [x] true) [true])
(filter (fn [x] true) '(true))
(filter (fn [x] true) '(false))
(filter (fn [x] false) '(false))
(filter (fn [x] false) '(false 1 2))
(filter (fn [x] true) '(1 2 3 ))
(filter (fn [x] (<= x 3) '(1 2 3 4 5)))
(filter (fn [x] (<= x 3)) '(1 2 3 4 5))
(reduce (fn [a b] (* a b)) [1 2 3 4])
(reduce (fn [a b] (if (< a b) b a)) ['o' 'oo' 'ooo'])
(reduce (fn [a b] (if (< (count a) (count b)) b a)) ['o' 'oo' 'ooo'])
(count 'ooo')
(count "ooo")
(reduce (fn [a b] (if (< (count a) (count b)) b a)) ["o" "oo" "ooo"])
(quote :a)
(quote :a :b :c)
(quote (:a :b :c))
(filter (fn [x] true) '(:a :b :c))
(= 2400 (reduce (fn [a b] (* a b)) (map (fn [x] (* x 10))) [1 2 3 4]))
(= 2400 (reduce (fn [a b] (* a b)) (map (fn [x] (* x 10)) [1 2 3 4]))
)
(= 2400 (reduce (fn [a b] (* a b)) (map (fn [x] (* x 10)) [1 2 3 4])))
(= 2400 (reduce (fn [a b] (* a b)) (if (>= x 2) (if (<= x 3) (map (fn [x] (* x 10)) [1 2 3 4]))))))
(= 2400 (reduce (fn [a b] (* a b)) (map (fn [x] (if (>= x 2) (if (<= x 3) (* x 10)) [1 2 3 4])))))
(= 2400 (reduce (fn [a b] (* a b)) (map (fn [x] (if (>= x 2) (if (<= x 3) (* x 10))) [1 2 3 4]))))
(= 2400 (reduce (fn [a b] (* a b)) (map (fn [x]) (if (>= x 2) (if (<= x 3) (* x 10))) [1 2 3 4])))
(= 2400 (reduce (fn [a b] (* a b)) (map (fn [x] (if (>= x 2) (if (<= x 3) (* x 10)))) [1 2 3 4])))
(= 2400 (reduce (fn [a b] (* a b)) 10 [1 2 3 4])))
(reduce (fn [a b] (* a b)) 10 [1 2 3 4]))
(reduce (fn [a b] (* a b)) 100 [1 2 3 4]))
(reduce (fn [a b] (* a b)) 100 [1 2 3 4])))
(reduce (fn [a b] (* a b)) 100 [1 2 3 4])
(defmulti diet (fn [x] (:eater x)))
(diet {:name "Clyde"})
(diet {:name "Clyde" :eater :carnivore})
(defmethod diet :default [a] (println a.name))
(defmethod diet :default [a] (println a))
(diet {:name "Clyde" :eater :carnivore})
(defmethod diet :default [a] (println a.:name))
(defmethod diet :default [a] (println (keys a)))
(diet {:name "Clyde" :eater :carnivore})
(defmethod diet :default [a] (println (get a :name)))
(diet {:name "Clyde" :eater :carnivore})
(defmethod diet :default [a] (println "Hello, " (get a :name)))
(diet {:name "Clyde" :eater :carnivore})
(defmethod diet :default [a] (println "Hello," (get a :name)))
(diet {:name "Clyde" :eater :carnivore})
(defmethod diet :default [a] (return "Hello," (get a :name)))
(defmethod diet :default [a] (println "Hello," (get a :name)))
(defmethod diet :default [a] (return "Hello," (get a :name)))
(defmethod diet :default [a] (println "Hello," (get a :name)))
(diet {:name "Clyde" :eater :carnivore})
(= "Hello, Clyde" (diet {:name "Clyde"}))
(defmethod diet :default [a] (str "Hello," (get a :name)))
(= "Hello, Clyde" (diet {:name "Clyde"}))
(diet {:name "Clyde" :eater :carnivore})
(defmethod diet :default [a] (str "Hello, " (get a :name)))
(= "Hello, Clyde" (diet {:name "Clyde"}))
(range 1 5)
(range 5)
(take 5 (iterate inc 0))
(iterate 10 :foo)
(take 5 (iterate inc :foo))
(take 5 (iterate (partial * 5) :foo))
(repeat 10 :a)
(take 5 (iterate (partial * 5) 3))
(take 5 (iterate (partial :foo) :foo))
(take 5 (iterate (partial str :foo) :foo))
(take 5 (iterate (fn :foo) :foo))
(take 5 (iterate (fn a) :foo))
(take 5 (iterate (fn a :foo))
)
(take 5 (iterate  :foo))
(take 5 (iterate (fn [a] a) :foo))
(for [index (range 6)] index)
(map (fn [index] (* index index))
          (filter odd? (range 10)))
     (for [index (range 10) :when (odd? index)]
       index)
(map (fn [index] (* index index))
          (filter odd? (range 10)))
((map (fn [index] (* index index))
          (filter odd? (range 10)))
     (for [index (range 10) :when (odd? index)]
       index)
)
(for [index (range 10) :when (odd? index)]
       index))
(for [index (range 10) :when (odd? index)] index)
 (for [index (range 6)] index)
(map (fn [index] (* index index)) (range 6))
(map (fn [index] (* index index)) (range 6)) (for [index (range 6)] index)
(range 6)
(map (fn [index] (* index index)) (range 6)) (for [index (range 6)] (* index index))
(filter odd? (range 10))
(for [index (range 10) :when (odd? index)] index)
(for [row [:top :middle :bottom] column [:left :middle :right]] [row column])
(complement symbol?)
(map not-a-symbol? [:a 'b "c"])
(let [not-a-symbol? (complement symbol?)] (map not-a-symbol? [:a 'b "c"]))
(nil? nil)
((compliment nil?) nil)
((complement nil?) nil)
(let [multiply-by-5 (partial * 5)] 4)
(let [multiply-by-5 (partial * 5)] (multiply-by-5 4))
(partial concat [:a :b])
(partial concat [:a :b]) 4
(partial concat [:a :b]) 4 5
((partial concat [:a :b]) 4)
((partial concat [:a :b]) "as" "well)
)
((partial concat [:a :b]) "as" "well")
((partial concat [:a :b]) "a" "b")
(comp square inc)
(let [inc-and-sq (comp square inc)] inc-and-sq 4)
(defn square [x] (* x x))
(comp square inc)
(let [inc-and-sq (comp square inc)] inc-and-sq 4)
(let [inc-and-sq (comp square inc)] (inc-and-sq 4))
dec
(dec 4)
(let [ab-adder (partial concat [:a :b])] (ab-adder ["a" "b"]))
(let [square-and-dec (comp square dec)] (square-and-dec 10))
(let [square-and-dec (comp dec square)] (square-and-dec 10))
is-even?
(defn is-even? [n] (if (= n 0) true (recur (is-even? (dec n)))))
(is-even? 1)
(is-even? 0)
(defn is-even? [n] (if (= n 0) true (return (is-even? (dec n)))))
(defn is-even? [n] (if (= n 0) true (recur (is-even? (dec n)))))
(is-even? 1)
(defn is-even? [n]
(if (= n 0)
true
(recur (is-even? (dec n)))))
(is-even? 1)
(if (= n 0)
(is-even? 0)
(dec 3)
(is-even? 2)
(apply < nums)
(apply < [2 5 1 56]))
(apply < [2 5 1 56])
(apply < [2 5  56])
#inst
)
(println #uuid)
slurp
json
import json
use json
(use json)
("Hi" conj 1) 
conj
(conj "hi" 1)
(conj [1] (4))
([1] conj (4))
([1] conj [4])
(conj [1] [4])
(conj [1] 4)
(conj [1] "hi")
(conj [1] ("hi" "by" "trie"))
(conj [1] "hi" "by" "trie")
(conj [1] '("hi" "by" "trie"))
(conj [1] @("hi" "by" "trie"))
(conj (1) "hi" "by" "trie")
(conj '(1) "hi" "by" "trie")
(def off {:qb 75 :rb 80 })
off
(def off {:qb 75 :rb 80 :wr1 45})
(defn create-off [] ({:qb (randint 60 90)}))
randint
(defn create-off [] ({:qb (rand-int 60 90)}))
(defn off create-off)
(create-off)
(defn create-off [] ({:qb (rand-int 90)}))
(create-off)
(rand-int 90)
(+ 60 (rand-int 30))
(do-times 30 (+ 60 (rand-int 30)))
(dotimes 30 (+ 60 (rand-int 30)))
(dotimes  (+ 60 (rand-int 30)) 30 )
(dotimes [ (+ 60 (rand-int 30))] 30 )
(dotimes [n 30] (+ 60 (rand-int 30)))
(dotimes [n 30] (println (+ 60 (rand-int 30))))
(dotimes [n 30] (println (+ 60 (rand-int 31))))
(defn rand6090 [] (+60 (rand-int 31)))
(if (< 75 (rand-int 100))
(println success)
(println failure))
(if (< 75 (rand-int 100))
(println :success)
(println :failure))
(rand-int 100)
(defn play-outcome (if (< 75 (rand-int 100))
(println :success)
(println :failure))
)
(defn play-outcome [] (if (< 75 (rand-int 100))
(println :success)
(println :failure)))
(play-outcome)
(dotimes 10 (play-outcome))
(dotimes [10] (play-outcome))
(dotimes [n 10] (play-outcome))
(defn play-outcome [] (if (> 75 (rand-int 100))
(println :success)
(println :failure)))
(dotimes [n 10] (play-outcome))
(defn play-outcome [rating] (if (> rating (rand-int 100))
(println :success)
(println :failure)))
(let [gain 0])
(* 90 .01
)
(* 90 0.01)
(play-outcome)
(play-outcome 75)
(if (= :success (play-outcome 75))
(println 75 * 0.01)
(println 0)
)
(if (= :success (play-outcome 75)) (println 75 * 0.01) (println 0))
(defn play-outcome [rating] (if (> rating (rand-int 100))
(:success)
(:failure))
)
(if (= :success (play-outcome 75)) (println 75 * 0.01) (println 0))
(= :success (play-outcome 75))
(play-outcome 75)
(defn play-outcome [rating] (if (> rating (rand-int 100)) :success :failure))
(play-outcome 75)
(if (= :success (play-outcome 75)) (println 75 * 0.01) (println 0))
(if (= :success (play-outcome 75)) (println (* 75 0.01)) (println 0))
(let [gain []] (if (= :success (play-outcome 75)) (conj gain (* 75 0.01)) gain))
(let [gain []] (if (= :success (play-outcome 75)) (conj gain (* 75 0.01)) (sum gain)))
(let [gain []] (if (= :success (play-outcome 75)) (conj gain (* 75 0.01)) (cumulative-sum gain)))
(let [gain []] (if (= :success (play-outcome 75)) (conj gain (* 75 0.01)) (reduce + gain)))
(defn running-play [rating] (let [gain []])
(if (= :success (play-outcome rating))
(conj gain running-play)
gain)
)
(defn running-play [rating] (let [gain []]
(if (= :success (play-outcome rating))
gain))
)
(running-play 75)
(defn running-play [rating] (let [gain []]
(if (= :success (play-outcome rating))
(reduce + gain))))
(running-play 75)
(defn running-play [rating] (let [gain []]
(if (= :success (play-outcome rating))
(conj gain running-play)
(reduce + gain))))
(running-play 75)
(defn running-play [rating] (let [gain []]
(if (= :success (play-outcome rating))
(conj gain (running-play rating))
(reduce + gain))))
(running-play 75)
(ns-interns *ns*)
(play-outcome 75)
source
(source running-play)
(source 'running-play)
(source running-play)
(source user/running-play)
(source #'user/running-play)
(reduce + (map * [(b) (b)] (reductions + (iterate (partial * 0.9) 1))))
(defn b [] (+ 1 (rand-int 4)))
(reduce + (map * [(b) (b)] (reductions + (iterate (partial * 0.9) 1))))
(defn b [] (+ 1 (rand-int 4)))
(reduce + (map * [(b) (b)] (reductions + (iterate (partial * 0.9) 1))))
(def rating 75)
(reduce + (map * [(b) (b)] (reductions + (iterate (partial * (* rating 0.01) 1))))
)
(* rating 0.01)
(reduce + (map * [(b) (b)] (reductions + (iterate (partial * (* rating 0.01)) 1))))
(defn rush (reduce + (map * [(b) (b)] (reductions + (iterate (partial * (* rating 0.01)) 1)))))
(defn rush [rating] (reduce + (map * [(b) (b)] (reductions + (iterate (partial * (* rating 0.01)) 1)))))
(rush rating)
ceil
floor
(use 'clojure.contrib.math.floor)
(use 'contrib.math.floor)
(use 'math.floor)
Math/floor
/Math/floor
(use 'clojure.math.floor)
(require 'clojure.math.floor)
(use 'java.lang.math.floor)
(use clojure.contrib.generic.math-functions)
(use 'clojure.contrib.generic.math-functions)
(use 'java.lang.Math.floor)
Math
Math.floor
Math/floor
Math/PI
Math/ceil
Math/Ceil
Math/pow
(. Math floor 4.5)
(. Math floor (rush rating))
play-outcome
(take-while true (play-outcome 75))
(play-outcome 75)
(defn segment-success? [rating] (if (> rating (rand-int 100)) true false))
(sement-success? 75)
(segment-success? 75)
(take-while true (segment-success? 75))
(for [x (segment-success? 75) :while true])
(take 100 (for [x (segment-success? 75) :while true]))
(take 100 (for [x (segment-success? 75) :while true] [x]))
(take-while true (conj [] (segment-success? 75)))
(conj [] true)
(take-while true (conj [] true))
(take-while true [true])
(take-while (true) [true])
(take-while (= true) [true])
(take-while (= true true) [true])
(take-while #(true) [true])
(dotimes 10 (segment-success? 75))
(dotimes [n 10] (segment-success? 75))
(defn segment-success? [rating] (dotimes [n 100] (if (> rating (rand-int 100)) true false)))
(take-while true (segment-success? 75))
(take-while (true) (segment-success? 75))
(take-while #(true) (segment-success? 75))
(println (segment-success? 75))
p
(def p (segment-success? 75))
p
println p
(println p)
(dotimes [n 100] (if (> rating (rand-int 100)) true false))
(dotimes [n 100] (println (if (> rating (rand-int 100)) true false)))
(conj [] (dotimes [n 100] (println (if (> rating (rand-int 100)) true false))))
(conj [] (dotimes [n 2] (true)))
(conj [] (dotimes [n 2] true))
(conj [] true)
(conj () (dotimes [n 2] true))
(dotimes [n 2] true)
(dotimes [n 2] #(true))
#(true)
(= true #(true))
(= (true) #(true))
(= true #(true))
(conj () #(dotimes [n 2] true))
(conj [] #(dotimes [n 2] true))
(def p (take-while (true) [true true false]))
(true)
(defn segment-success? [rating] (dotimes [n 100] (if (> rating (rand-int 100)) true false)))
(segment-sccuess? 75)
(segment-success? 75)
(def s (segment-success? 75))
s
(defn segment-success? [rating] (if (> rating (rand-int 100)) true false))
(segment-success? 75)
play-outcome
(play-outcome 75)
(defn segment-success? [rating] (conj [] (dotimes [n 100] (if (> rating (rand-int 100)) true false))))
(segment-success? 75)
(defn segment-success? [rating] (dotimes [n 100] (conj [] (if (> rating (rand-int 100)) true false))))
(segment-success? 75)
(def s (segment-success? 75))
s
(defn segment-success? [rating] (if (> rating (rand-int 100)) true false))
(segment-success? 75)
(conj [] (dotimes [n 10] (segment-success? 75)))
(conj [] (segment-success? 75))
(dotimes [n 10] (conj [] (segment-success? 75)))
#(%)
(#(%) "Hi")
(#(str %) "Hi")
(#(str %) Hi)
(#(str %) "Hi")
(#(str %) "Hi" "There")
(#(str % %) "Hi" "There")
(#(conj % %) "Hi" "There")
(#(conj % n) "Hi" "There")
(defmacro list-comp [[binding seq-expr & bindings] body-expr]
  (cond (not binding)
        `(list ~body-expr)
        (= :when binding)
        `(when ~seq-expr (list-comp ~bindings ~body-expr))
        :else
        `(mapcat (fn [~binding] (list-comp ~bindings ~body-expr))
                 ~seq-expr)))
(list-comp [x (range 10) x)
(list-comp [x (range 10)] x)
(exit)
